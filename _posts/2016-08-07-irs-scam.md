---
layout: post
title:  "IRS Scam"
date:   2016-08-07
categories: scams
---

A friend of mine and I received a message from the IRS at nearly the same time. 
<p>
    <img style="border:1px solid black;" src="/assets/initial_irs_text.jpeg" alt="drawing" width="200"/>
    <em>The Bait</em>
</p>

I replied to them, in hopes that I would be eligible to receive slightly more than the offered amount... 

<p>
    <img style="border:1px solid black;" src="/assets/irs_minion.jpeg" alt="drawing" width="200"/>
    <em>The Dissapointment</em>
</p>

but got no response. This is when I started to suspect something was off. 

When I tried opening the link on my computer, it did not work -- the page could not be found. Opening the link on both MacOS and Windows machines gave no result, either. So, either the scammers severely misconfigured their infrastructure, or there's some silliness going on here.

Looking back to the original phishing message, we can see that it *does* specify Safari as the browser of choice... interesting. Maybe the receiving server is configured only to respond to web requests incoming from Safari browsers/User Agents. I tried crafting a request that would satisfy these requirements, but after struggling for far too long, I opted to instead open the link on my phone while monitoring its traffic and webpage elements on my computer -- an incredibly deep thank you to the following sources for helping me create this Rube Goldberg-eque phish detonation setup:

* [Inspecting web elements on iPhone via connecting to a MacBook](https://www.headspin.io/blog/tips-and-tricks-for-using-inspect-element-on-ios)
* [Viewing network traffic on an iPhone with BurpSuite](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)


Finally! I could view the first page of the scam site:

<img style="border:1px solid black;" src="/assets/irs_first_page.jpeg" alt="drawing" width="200"/>

Selecting "Get My Payment", we are directed to this page:

<img style="border:1px solid black;" src="/assets/irs_second_page.jpeg" alt="drawing" width="200"/>

After filling out the fields with bogus information, I collected the .php and .js pages used to load and process the collected data. In order to prevent the usage of this malicious code elsewhere, the full deobfuscated code will not be posted here; however, I will go over chunks of the code later in this post.

Moving on to the third, final page of the site:

<img style="border:1px solid black;" src="/assets/irs_third_page.jpeg" alt="drawing" width="200"/>

we finally get to the section which the scammers' entire operation hinges on: collecting credit card information. Upon filling these fields out and submitting the information, we are either told our credit card is invalid and that we must try again (bummer) or we are redirected to an official IRS webpage with a banner notifying us of recent scams (bummer).


We can finally get to the good part :)

## The Javascript

The site uses two Javascript files, `functions.js`{:.js} and `characters.js`{:.js}, conveniently named so we know how easily confused the scammers are. 

Looking at the smaller file, `characters.js`{:.js}, we find a common method of obfuscation implemented by scam sites: a shuffled array of a wide variety of words.

The file consists of three functions:
1. The first returns the entirety of the array
2. The second retrieves an element from the array based on a passed index
3. The third unshuffles the array, so that it can be used by the rest of the scripts 


### get_word_array()
The first function is straightforward. It contains the array, and returns it. For the sake of readability, I'll refer to it as get_word_array()

### get_word_from_array(index)
I will refer to the second function as get_word_from_array(*index*). Before we can dissect how the array is unshuffled, we have to learn about how get_word_from_array(*index*) is used. For instance, take this line:

```js
_0xdeadbeef = "https://"[get_word_from_array(340)]("ir")+get_word_from_array(560)+"/"+get_word_from_array(220)
```

the function get_word_from_array(*index*) retrieves an element from the array, given a specific index. Oftentimes, the function will take the passed index and subtract a hard-coded offset to calculate the element's *true* index, as follows:

```js
function get_word_from_array(index)
{
    var word_array = get_word_array();
    const offset = SOME_NUMBER;
    return word_array[index-offset];
}
```
With this, we can begin to deobfuscate our jumbled code. Using get_word_from_array(*index*), we plug in the arguments seen in the code and get the following:
* get_word_from_array(340) => ".concat"
* get_word_from_array(560) => "scam.com"

So, now we have
```js
_0xdeadbeef = "https://"[".concat"]("ir")+"scam.com"+"/"+"sendCode"
```
By the sacred, ridiculous rules of Javascript we can change ".concat" into the .concat() function due to the brackets enveloping the String. Simplifying the code more, we get:
```js
_0xdeadbeef = "https://".concat("ir")+"scam.com"+"/sendCode"
```
Put it all together, and we get
```js
_0xdeadbeef = "https://irscam.com/sendCode"
```
likely an endpoint to either send or receive data!

### Unshuffling the Array
We can now approach dissecting the obfuscated array unshuffler. Here's an example of one such unshuffler (I've taken the liberty of deobfuscating it and converting it to Python for readbility and general mental health):


```python
while True:
    try:
        calculated_number = -parse_int(get_word_from_array(372)) / 1 + -parse_int(get_word_from_array(370)) / 2 + parse_int(get_word_from_array(362)) / 3 + -parse_int(get_word_from_array(359)) / 4 * (-parse_int(get_word_from_array(361)) / 5) + -parse_int(get_word_from_array(369)) / 6 + -parse_int(get_word_from_array(368)) / 7 * (parse_int(get_word_from_array(367)) / 8) + -parse_int(get_word_from_array(355)) / 9 * (-parse_int(get_word_from_array(357)) / 10)
        if(calculcated_number == 346304):
            break
        else:
            word_array.append(word_array.pop(0))
    except Exception as e:
        word_array.append(word_array.pop(0))
```

Yowza.

It looks like a lot, but the logic is very simple. We'll make it more readable to make this clear:

```python
while True:
    try:
        num_1 = parse_int(get_word_from_array(372))
        num_2 = parse_int(get_word_from_array(370))
        num_3 = parse_int(get_word_from_array(362))
        num_4 = parse_int(get_word_from_array(359))
        num_5 = parse_int(get_word_from_array(361))
        num_6 = parse_int(get_word_from_array(369))
        num_7 = parse_int(get_word_from_array(368))
        num_8 = parse_int(get_word_from_array(367))
        num_9 = parse_int(get_word_from_array(355))
        num_10 = parse_int(get_word_from_array(357))

        calculated_number = -num_1 / 1 + -num_2 / 2 + num_3 / 3 + -num_4 / 4 * (-num_5 / 5) + -num_6 / 6 + -num_7 / 7 * (num_8 / 8) + -num_9 / 9 * (-num_10 / 10)

        if(calculated_number == 346304):
            break
        else:
            word_array.append(word_array.pop(0))

    except Exception as e:
        word_array.append(word_array.pop(0))
```

The unshuffler takes an existing, "shuffled" array of elements, and begins to run a loop. 

get_word_from_array(*index*) is used to retrieves elements from hardcoded indices, extracting the Integer content from the String (if any). 

If, when plugged into the equation, the result of all these Integer values does not equal a <mark style="background-color: #B0DCEB">Specific Value</mark> (in this instance 346304), the loop continues. The first element of the array is pushed to the back. In the event no Integer values can be extracted, an error occurs, and the same pushing of the first element is carried out.

This cycle continues until the calculcated value is equal to the <mark style="background-color:  #B0DCEB">Specific Value</mark> -- when this occurs, the loop breaks. The array has been "unshuffled"! It can now be used throughout the rest of the script to retrieve the correct elements from the array.

The act of calling get_word_from_array(*index*) must be repeated for almost every line of obfuscated code to determine its true purpose -- this is a process perfect for medidation or hobbyist dissociation.

## The Site's Capabilities

The file `functions.js`{:.js} is used to enable the site's scamming capabilities. 

When the user moves from one page to the next, every click of the button sends a POST web request to a the URL of the same page, with an additional extension on it. This ensures that the scammers are able to collect at least some information from the victim, even if they do not go through with filling out their credit card information.