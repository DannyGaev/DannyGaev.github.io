---
layout: post
title:  "IRS Scam"
date:   2016-08-07
categories: scams
---

A friend of mine and I received a message from the IRS at nearly the same time. 

<img src="/assets/initial_irs_text.jpeg" alt="drawing" width="200"/>

I replied to them, in hopes that I would be eligible to receive slightly more than the offered amount... 

<img src="/assets/irs_minion.jpeg" alt="drawing" width="200"/>

but got no response. This is when I started to suspect something was off. 

When I tried opening the link on my computer, it did not work -- the page could not be found. Opening the link on both MacOS and Windows machines gave no result, either. So, either the scammers severely misconfigured their infrastructure, or there's some silliness going on here.

Looking back to the original phishing message, we can see that it *does* specify Safari as the browser of choice... interesting. Maybe the receiving server is configured only to respond to web requests incoming from Safari browsers/User Agents. I tried crafting a request that would satisfy these requirements, but after struggling for far too long, I opted to instead open the link on my phone while monitoring its traffic and webpage elements on my computer -- an incredibly deep thank you to the following sources for helping me create this Rube Goldberg-eque phish detonation setup:

* [Inspecting web elements on iPhone via connecting to a MacBook](https://www.headspin.io/blog/tips-and-tricks-for-using-inspect-element-on-ios)
* [Viewing network traffic on an iPhone with BurpSuite](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)


Finally! I could view the first page of the scam site:

<img src="/assets/irs_first_page.jpeg" alt="drawing" width="200"/>

Selecting "Get My Payment", we are directed to this page:

<img src="/assets/irs_second_page.jpeg" alt="drawing" width="200"/>

After filling out the fields with bogus information, I collected the .php and .js pages used to load and process the collected data. In order to prevent the usage of this malicious code elsewhere, the full deobfuscated code will not be posted here; however, I will go over chunks of the code later in this post.

Moving on to the third, final page of the site:

<img src="/assets/irs_third_page.jpeg" alt="drawing" width="200"/>

we finally get to the section which the scammers' entire operation hinges on: collecting credit card information. Upon filling these fields out and submitting the information, we are either told our credit card is invalid and that we must try again (bummer) or we are redirected to an official IRS webpage with a banner notifying us of recent scams (bummer).


We can finally get to the good part :)

## The Javascript

The site uses two Javascript files, `functions.js`{:.js} and `characters.js`{:.js} -- conveniently named so we know how easily confused the scammers are -- to accomplish its goals. Looking at the smaller file, characters.js, we can see a common function implemented by scam sites: an array unshuffler. 

In order to better hide their behavior, scripts can be obfuscated by relying less on straightforward variable names and actions, and rather on storing these elements within a larger array and using a designated function to extract them using their respective positions in the array throughout the code. That's confusing. 


Before we can dissect the array unshuffler, we have to learn about how these sorts of obfuscated scripts retrieve values from the array. For instance, we can encounter this line:


```js
_0xdeadbeef = "https://"[get_word_from_array(340)]("ir")+get_word_from_array(560)
```

the function get_word_from_array(index) does exactly that -- it retrieves an element from the array, given a specific index. Oftentimes, the function will take the passed index and use it to calculate the element's *true* index using a hard-coded offset, as follows:


```js
function get_word_from_array(index)
{
    var word_array = get_word_array();
    const offset = SOME_NUMBER;
    return word_array[index-offset];
}
```

With this, we can begin to deobfuscate our jumbled code. Using get_word_from_array(*index*), we plug in the arguments seen in the code and get the following:
* get_word_from_array(340) => ".concat"
* get_word_from_array(560) => "scam.com"

So, now we have
```js
_0xdeadbeef = "https://"[".concat"]("ir")+"scam.com"
```

By the sacred, ridiculous rules of Javascript we can change ".concat" into the .concat() function due to the brackets enveloping the String. So, we have this:
```js
_0xdeadbeef = "https://".concat("ir")+"scam.com"
```

Put it all together, and we get
```js
_0xdeadbeef = "https://irscam.com"
```
likely an endpoint to either send or receive data! (The process of calling get_word_from_array(*index*) to determine the correct element has to be repeated for every line of obfuscated code to derive its true purpose -- a time perfect for medidation or hobbyist dissociation.)

With this get_word_from_array(*index*) function, we can approach dissecting the obfuscated array unshuffler. Here's an example of one such unshuffler (I've taken the liberty of deobfuscating it and converting it to Python for readbility and general mental health):


```python
while True:
    try:
        calculated_number = -parse_int(get_word_from_array(372)) / 1 + -parse_int(get_word_from_array(370)) / 2 + parse_int(get_word_from_array(362)) / 3 + -parse_int(get_word_from_array(359)) / 4 * (-parse_int(get_word_from_array(361)) / 5) + -parse_int(get_word_from_array(369)) / 6 + -parse_int(get_word_from_array(368)) / 7 * (parse_int(get_word_from_array(367)) / 8) + -parse_int(get_word_from_array(355)) / 9 * (-parse_int(get_word_from_array(357)) / 10)
        if(calculcated_number == 346304):
            break
        else:
            word_array.append(word_array.pop(0))
    except Exception as e:
        word_array.append(word_array.pop(0))
```

Yowza.

It looks like a lot, but the logic is very simple. We'll make it more readable to make this clear:

```python
while True:
    try:
        num_1 = parse_int(get_word_from_array(372))
        num_2 = parse_int(get_word_from_array(370))
        num_3 = parse_int(get_word_from_array(362))
        num_4 = parse_int(get_word_from_array(359))
        num_5 = parse_int(get_word_from_array(361))
        num_6 = parse_int(get_word_from_array(369))
        num_7 = parse_int(get_word_from_array(368))
        num_8 = parse_int(get_word_from_array(367))
        num_9 = parse_int(get_word_from_array(355))
        num_10 = parse_int(get_word_from_array(357))

        calculated_number = -num_1 / 1 + -num_2 / 2 + num_3 / 3 + -num_4 / 4 * (-num_5 / 5) + -num_6 / 6 + -num_7 / 7 * (num_8 / 8) + -num_9 / 9 * (-num_10 / 10)

        if(calculated_number == 346304):
            break
        else:
            word_array.append(word_array.pop(0))

    except Exception as e:
        word_array.append(word_array.pop(0))
```

The unshuffler takes an existing, "shuffled" array of elements, and begins to run a loop. Using the get_word_from_array(*index*) function we went over, it retrieves elements from hardcoded indices, and extracts their Integer content (if any). If, when plugged into an equation, the result of all these Integer values does not equal a specific value (in this case, 346304), the loop continues and the first element of the array is pushed to the back. This continues until the calculated_value is equal to the specific value -- when this occurs, the loop breaks. The array has been "unshuffled"! It can now be used throughout the rest of the script to retrieve the correct elements from the array.



